---
title: 【自然语言处理入门】03：利用线性回归对数据集进行分析预测（下）
date: 2017-12-21 19:03:10
thumbnail:  https://raw.githubusercontent.com/xiongzongyang/hexo_photo/master/nlp1.jpg
tags: 自然语言处理
categories: [NLP,MDCourse]
---
> 上一篇中我们简单的介绍了[利用线性回归分析并预测波士顿房价数据集](https://xiongzongyang.github.io/2017/12/21/%E3%80%90%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8%E3%80%9103%EF%BC%9A%E5%88%A9%E7%94%A8%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%AF%B9%E6%95%B0%E6%8D%AE%E9%9B%86%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90%E9%A2%84%E6%B5%8B%EF%BC%88%E4%B8%8A%EF%BC%89/)，那么在这一篇中，将使用相同的模型来对红酒数据集进行分析。
> <!--more-->

### 1 基本要求
利用线性回归，对红酒数据集进行分析。数据集[下载地址](https://github.com/xiongzongyang/hexo_photo)。
### 2 完整代码

```
#-*- coding: UTF-8 -*-
# @Time    : 2017/12/21 9:29
# @Author  : xiongzongyang
# @Software: PyCharm

import pandas as pd
from pandas import Series, DataFrame
import numpy as np
from sklearn.linear_model import LinearRegression #线性回归
from sklearn.metrics import mean_squared_error
import matplotlib as mpl
import matplotlib.pyplot as plt

#读取数据
def read_data(data_path="./data/"):
    test_data = pd.read_csv(data_path+"test.csv", header=None)
    train_data = pd.read_csv(data_path+"train.csv", header=None)
    return train_data,test_data
#数据处理
def deal_data(pd_data):
    #获取数据的行数,因为要出去字段名，所以要-1
    row_cnt = pd_data.shape[0]-1
    #计算列数，因为在读入数据时，没有指定分隔符，所以所有列数据都是作为一列数据来读入的，因此在计算列数时，将读入的每一行按照;来分开
    column_cnt = len(pd_data.iloc[0, 0].split(";"))
    #empty 会创建一个没有使用特定值来初始化的数组。给这些方法传递一个元组作为形状来创建高维数组：
    X = np.empty((row_cnt, column_cnt - 1))
    Y = np.empty((row_cnt, 1))
    column_name=pd_data.iloc[0, 0].split(";")
    #开始获取数据
    for i in range(0, row_cnt):
        #逐一将每一行进行分割（按;空格分割）
        row_array = pd_data.iloc[i+1, 0].split(";")
        #x取前13个数据，X[i]是一个一维数组，则X相当于一个二维数组，Y同理
        X[i] = np.array(row_array[0:-1])
        #y取最后一个数据
        Y[i] = np.array(row_array[-1])
    return X, Y,column_name
#把特征标准化为均匀分布
def uniform_norm(X):
    X_max = X.max(axis=0)
    X_min = X.min(axis=0)
    return (X - X_min) / (X_max - X_min), X_max, X_min

#实现线性回归
#画图
def draw(pred,test_Y):
    t = np.arange(len(pred))
    mpl.rcParams['font.sans-serif'] = [u'simHei']
    mpl.rcParams['axes.unicode_minus'] = False
    plt.figure(facecolor='w')
    plt.plot(t, test_Y, 'r-', lw=2, label=u'true value')
    plt.plot(t, pred, 'b-', lw=2, label=u'estimated')
    plt.legend(loc='best')
    plt.title(u'wine quality', fontsize=18)
    plt.xlabel(u'case id', fontsize=15)
    plt.ylabel(u'quality', fontsize=15)
    plt.grid()
    plt.show()
#模型评估
def evaluate(unif_train_X,train_Y,unif_test_X,test_Y):
    print("训练集上效果评估:")
    pred_train = model.predict(unif_train_X)
    print("R^2系数 ", model.score(unif_train_X, train_Y))
    print("均方误差 ", mean_squared_error(train_Y, pred_train))
    print("\n测试集上效果评估 :")
    r2 = model.score(unif_test_X, test_Y)
    print("R^2系数 ", r2)
    pred = model.predict(unif_test_X)
    print("均方误差 ", mean_squared_error(test_Y, pred))

#主函数
if __name__ == "__main__":
    #读取数据
    train_data,test_data=read_data()
    #数据处理
    train_X, train_Y,column_name=deal_data(train_data)
    # print(train_X.shape)
    # print(train_Y.shape)
    test_X, test_Y,column_name=deal_data(test_data)
    # print(test_X.shape)
    # print(test_Y.shape)
    #把特征标准化为均匀分布
    unif_train_X, max_X, min_X = uniform_norm(train_X)
    unif_test_X = (test_X - min_X) / (max_X - min_X)
    #实现线性回归
    model = LinearRegression()
    model.fit(unif_train_X, train_Y)
    #在训练集上预测
    pred_train = model.predict(unif_train_X)
    #在测试集上预测
    pred = model.predict(unif_test_X)
    #画图
    draw(pred,test_Y)
    #模型评估
    evaluate(unif_train_X,train_Y,unif_test_X,test_Y)
```
注意：本数据集中，每一列都有列名，因此在数据预处理的过程中要去掉。
### 3 实验结果
![image](https://raw.githubusercontent.com/xiongzongyang/hexo_photo/master/QQ%E5%9B%BE%E7%89%8720171221191054.png)

### 4 实验小结
结果这两个实验可以看出，一般数据分析处理流程如下图所示。

```
graph LR
数据读取-->数据预处理
选择模型-->训练模型
数据预处理-->训练模型
训练模型-->测试模型
测试模型-->模型评估
```
